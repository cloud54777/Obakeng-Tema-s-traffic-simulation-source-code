(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))s(a);new MutationObserver(a=>{for(const r of a)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&s(n)}).observe(document,{childList:!0,subtree:!0});function e(a){const r={};return a.integrity&&(r.integrity=a.integrity),a.referrerPolicy&&(r.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?r.credentials="include":a.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(a){if(a.ep)return;a.ep=!0;const r=e(a);fetch(a.href,r)}})();const i={CANVAS_WIDTH:1200,CANVAS_HEIGHT:1200,INTERSECTION_SIZE:120,ROAD_WIDTH:60,LANE_WIDTH:15,CAR_WIDTH:16,CAR_HEIGHT:8,CAR_COLORS:["#FF0000","#00FF00","#0000FF","#FFFF00","#FFA500","#FFFFFF","#000000","#888888"],DIRECTIONS:{NORTH:"north",SOUTH:"south",EAST:"east",WEST:"west"},TURN_TYPES:{STRAIGHT:"straight",LEFT:"left",RIGHT:"right"},MODES:{FIXED:"fixed",ADAPTIVE:"adaptive"},LIGHT_SIZE:6,LIGHT_STATES:{RED:"red",YELLOW:"yellow",GREEN:"green"},DEFAULT_SETTINGS:{GREEN_DURATION:1e5,YELLOW_DURATION:5e3,RED_DURATION:1e5,CAR_SPAWN_RATE:4,CAR_SPEED:25,TURN_RATE:.4,DETECTOR_DISTANCE:500,MIN_GREEN_TIME:5e3},TURN_DELAYS:{LEFT:2e3,RIGHT:1500,STRAIGHT:0},HEADINGS:{NORTH:270,SOUTH:90,EAST:0,WEST:180},ADAPTIVE_SETTINGS:{DETECTOR_DISTANCE_RANGE:[100,500]}};function p(d,t,e,s,a){const r=[0],n=[e],c=[d],h=[t],l=[],T=[];for(let o=0;o<s.length;o++){r[o+1]=r[o]+s[o],n[o+1]=n[o]+a[o]*s[o];const S=Math.abs(a[o])<1e-6,g=S?1e6:1/a[o];S?(c[o+1]=c[o]+s[o]*Math.cos(n[o]),h[o+1]=h[o]+s[o]*Math.sin(n[o]),l[o]=1e6,T[o]=1e6):(l[o]=c[o]-g*Math.sin(n[o]),T[o]=h[o]+g*Math.cos(n[o]),c[o+1]=l[o]+g*Math.sin(n[o+1]),h[o+1]=T[o]-g*Math.cos(n[o+1]))}return{u:r,phi:n,x:c,y:h,xCenter:l,yCenter:T}}function I(d,t){let e=0;for(;d>t.u[e+1]&&e+1<t.xCenter.length;)e++;const s=(t.phi[e+1]-t.phi[e])/(t.u[e+1]-t.u[e]),a=Math.abs(s)<1e-6,r=a?1e6:1/s,n=a?t.x[e]+(d-t.u[e])*Math.cos(t.phi[e]):t.xCenter[e]+r*Math.sin(t.phi[e]+s*(d-t.u[e])),c=a?t.y[e]+(d-t.u[e])*Math.sin(t.phi[e]):t.yCenter[e]-r*Math.cos(t.phi[e]+s*(d-t.u[e]));return[n,c]}const m=25,A=40;p(0,0,0,[A,Math.PI*m/2],[0,1/m]);class N{constructor(t,e){this.centerX=t,this.centerY=e,this.size=i.INTERSECTION_SIZE,this.roadWidth=i.ROAD_WIDTH,this.laneWidth=i.LANE_WIDTH,this.calculatePositions()}initialize(){this.calculatePositions()}calculatePositions(){const t=this.size/2,e=this.roadWidth/2,s=this.laneWidth/2,a=t-5;this.stopLines={[i.DIRECTIONS.NORTH]:{x1:this.centerX-e,y1:this.centerY-a,x2:this.centerX+e,y2:this.centerY-a},[i.DIRECTIONS.EAST]:{x1:this.centerX+a,y1:this.centerY-e,x2:this.centerX+a,y2:this.centerY+e},[i.DIRECTIONS.SOUTH]:{x1:this.centerX-e,y1:this.centerY+a,x2:this.centerX+e,y2:this.centerY+a},[i.DIRECTIONS.WEST]:{x1:this.centerX-a,y1:this.centerY-e,x2:this.centerX-a,y2:this.centerY+e}},this.lightPositions={[i.DIRECTIONS.NORTH]:{x:this.centerX-50,y:this.centerY-t-50},[i.DIRECTIONS.EAST]:{x:this.centerX+t+20,y:this.centerY-50},[i.DIRECTIONS.SOUTH]:{x:this.centerX+50,y:this.centerY+t+30},[i.DIRECTIONS.WEST]:{x:this.centerX-t-50,y:this.centerY+50}},this.spawnPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX-s,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY-s},[i.DIRECTIONS.SOUTH]:{x:this.centerX+s,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY+s}},this.updateSpawnPointsForLanes();const r=this.laneWidth*.5;this.exitPoints={[i.DIRECTIONS.NORTH]:{x:this.centerX+r,y:0},[i.DIRECTIONS.EAST]:{x:i.CANVAS_WIDTH,y:this.centerY+r},[i.DIRECTIONS.SOUTH]:{x:this.centerX-r,y:i.CANVAS_HEIGHT},[i.DIRECTIONS.WEST]:{x:0,y:this.centerY-r}}}updateSpawnPointsForLanes(){const t=this.laneWidth*1.5,e=this.laneWidth*.5;this.spawnPointsByLane={[i.DIRECTIONS.NORTH]:[{x:this.centerX-e,y:0},{x:this.centerX-t,y:0},{x:this.centerX+e,y:i.CANVAS_HEIGHT},{x:this.centerX+t,y:i.CANVAS_HEIGHT}],[i.DIRECTIONS.EAST]:[{x:i.CANVAS_WIDTH,y:this.centerY-e},{x:i.CANVAS_WIDTH,y:this.centerY-t},{x:0,y:this.centerY+e},{x:0,y:this.centerY+t}],[i.DIRECTIONS.SOUTH]:[{x:this.centerX+e,y:i.CANVAS_HEIGHT},{x:this.centerX+t,y:i.CANVAS_HEIGHT},{x:this.centerX-e,y:0},{x:this.centerX-t,y:0}],[i.DIRECTIONS.WEST]:[{x:0,y:this.centerY+e},{x:0,y:this.centerY+t},{x:i.CANVAS_WIDTH,y:this.centerY-e},{x:i.CANVAS_WIDTH,y:this.centerY-t}]}}getSpawnPointForLane(t,e){return this.spawnPointsByLane[t]&&this.spawnPointsByLane[t][e]?this.spawnPointsByLane[t][e]:this.spawnPoints[t]}render(t){this.drawRoads(t),this.drawIntersection(t),this.drawLaneMarkings(t),this.drawStopLines(t)}drawRoads(t){const e=this.roadWidth/2;t.fillStyle="#444444",t.fillRect(this.centerX-e,0,this.roadWidth,i.CANVAS_HEIGHT),t.fillRect(0,this.centerY-e,i.CANVAS_WIDTH,this.roadWidth)}drawIntersection(t){const e=this.roadWidth/2,s=e;t.fillStyle="#666666",t.beginPath(),t.moveTo(this.centerX-e,this.centerY-e-s),t.quadraticCurveTo(this.centerX-e,this.centerY-e,this.centerX-e-s,this.centerY-e),t.lineTo(this.centerX-e-s,this.centerY+e),t.quadraticCurveTo(this.centerX-e,this.centerY+e,this.centerX-e,this.centerY+e+s),t.lineTo(this.centerX+e,this.centerY+e+s),t.quadraticCurveTo(this.centerX+e,this.centerY+e,this.centerX+e+s,this.centerY+e),t.lineTo(this.centerX+e+s,this.centerY-e),t.quadraticCurveTo(this.centerX+e,this.centerY-e,this.centerX+e,this.centerY-e-s),t.closePath(),t.fill(),t.globalCompositeOperation="source-over"}drawLaneMarkings(t){t.strokeStyle="#ffffff",t.lineWidth=2,t.setLineDash([10,10]);const e=this.roadWidth/2;t.beginPath(),t.moveTo(this.centerX,0),t.lineTo(this.centerX,this.centerY-e),t.moveTo(this.centerX,this.centerY+e),t.lineTo(this.centerX,i.CANVAS_HEIGHT);const s=this.centerX-this.laneWidth;t.moveTo(s,0),t.lineTo(s,this.centerY-e),t.moveTo(s,this.centerY+e),t.lineTo(s,i.CANVAS_HEIGHT);const a=this.centerX+this.laneWidth;t.moveTo(a,0),t.lineTo(a,this.centerY-e),t.moveTo(a,this.centerY+e),t.lineTo(a,i.CANVAS_HEIGHT),t.stroke(),t.beginPath(),t.moveTo(0,this.centerY),t.lineTo(this.centerX-e,this.centerY),t.moveTo(this.centerX+e,this.centerY),t.lineTo(i.CANVAS_WIDTH,this.centerY);const r=this.centerY-this.laneWidth;t.moveTo(0,r),t.lineTo(this.centerX-e,r),t.moveTo(this.centerX+e,r),t.lineTo(i.CANVAS_WIDTH,r);const n=this.centerY+this.laneWidth;t.moveTo(0,n),t.lineTo(this.centerX-e,n),t.moveTo(this.centerX+e,n),t.lineTo(i.CANVAS_WIDTH,n),t.stroke(),t.setLineDash([])}drawStopLines(t){t.strokeStyle="#ffffff",t.lineWidth=4,Object.values(this.stopLines).forEach(e=>{t.beginPath(),t.moveTo(e.x1,e.y1),t.lineTo(e.x2,e.y2),t.stroke()})}getStopLinePosition(t){return this.stopLines[t]}getSpawnPoint(t){switch(t){case"north":return{x:this.centerX,y:this.centerY-300};case"south":return{x:this.centerX,y:this.centerY+300};case"east":return{x:this.centerX+300,y:this.centerY};case"west":return{x:this.centerX-300,y:this.centerY};default:return}}getExitPoint(t){switch(t){case"north":return{x:this.centerX,y:this.centerY-300};case"south":return{x:this.centerX,y:this.centerY+300};case"east":return{x:this.centerX+300,y:this.centerY};case"west":return{x:this.centerX-300,y:this.centerY};default:return}}getLightPosition(t){if(!t||typeof t!="string"){console.warn("Invalid direction for getLightPosition:",t);return}return this.lightPositions[t]}isInIntersection(t,e){const s=this.roadWidth/2;return t>=this.centerX-s&&t<=this.centerX+s&&e>=this.centerY-s&&e<=this.centerY+s}getProperExitPoint(t,e,s){return this.laneWidth/2,this.exitPoints[e]}getTurningPath(t,e,s){return[this.getPathEntryPoint(t),this.exitPoints[e]]}getPathEntryPoint(t,e=0){const s=this.roadWidth/2,a=this.laneWidth,r=e===0?a*.5:a*1.5;switch(t){case i.DIRECTIONS.NORTH:return{x:this.centerX-r,y:this.centerY-s};case i.DIRECTIONS.EAST:return{x:this.centerX+s,y:this.centerY-r};case i.DIRECTIONS.SOUTH:return{x:this.centerX+r,y:this.centerY+s};case i.DIRECTIONS.WEST:return{x:this.centerX-s,y:this.centerY+r};default:return{x:this.centerX,y:this.centerY}}}setCarManager(t){this.carManager=t}getAllCars(){return this.carManager?this.carManager.getCars():[]}calculateTrajectory(t,e,s,a=0){try{const r=this.getPathEntryPoint(t,a),n=this.getExitPointForTurn(t,s,a);if(!r||!n)return console.error("Invalid entry/exit points for trajectory",{fromDirection:t,turnType:s,lane:a,entry:r,exit:n}),null;let c=[],h=[],l=this.getInitialHeading(t);if(s===i.TURN_TYPES.LEFT){const o=a===0?12:6,S=a===0?14:4,g=Math.PI/2*S;c=[o,g,o],h=[0,1/S,0]}else if(s===i.TURN_TYPES.RIGHT){const o=a===0?12:8,S=a===0?20:15,g=Math.PI/2*S;c=[o,g,o],h=[0,-1/S,0]}else c=[Math.sqrt((n.x-r.x)**2+(n.y-r.y)**2)],h=[0];const T=p(r.x,r.y,l,c,h);return console.log("Created LANE-SPECIFIC trajectory for",t,"->",s,"lane",a,"radius:",s!==i.TURN_TYPES.STRAIGHT?s===i.TURN_TYPES.LEFT?a===0?12:16:a===0?20:15:"N/A"),T}catch(r){return console.error("Error in calculateTrajectory:",r),null}}getInitialHeading(t){switch(t){case i.DIRECTIONS.NORTH:return Math.PI/2;case i.DIRECTIONS.EAST:return Math.PI;case i.DIRECTIONS.SOUTH:return-Math.PI/2;case i.DIRECTIONS.WEST:return 0;default:return 0}}getExitPointForTurn(t,e,s=0){const a=this.laneWidth,r=s===0?a*.5:a*1.5;switch(t){case i.DIRECTIONS.NORTH:switch(e){case i.TURN_TYPES.STRAIGHT:return{x:this.centerX+r,y:i.CANVAS_HEIGHT};case i.TURN_TYPES.LEFT:return{x:i.CANVAS_WIDTH,y:this.centerY+r};case i.TURN_TYPES.RIGHT:return{x:0,y:this.centerY-r}}break;case i.DIRECTIONS.SOUTH:switch(e){case i.TURN_TYPES.STRAIGHT:return{x:this.centerX-r,y:0};case i.TURN_TYPES.LEFT:return{x:0,y:this.centerY-r};case i.TURN_TYPES.RIGHT:return{x:i.CANVAS_WIDTH,y:this.centerY+r}}break;case i.DIRECTIONS.EAST:switch(e){case i.TURN_TYPES.STRAIGHT:return{x:0,y:this.centerY+r};case i.TURN_TYPES.LEFT:return{x:this.centerX-r,y:0};case i.TURN_TYPES.RIGHT:return{x:this.centerX+r,y:i.CANVAS_HEIGHT}}break;case i.DIRECTIONS.WEST:switch(e){case i.TURN_TYPES.STRAIGHT:return{x:i.CANVAS_WIDTH,y:this.centerY-r};case i.TURN_TYPES.LEFT:return{x:this.centerX+r,y:i.CANVAS_HEIGHT};case i.TURN_TYPES.RIGHT:return{x:this.centerX-r,y:0}}break}return this.exitPoints[t]}}class u{initialize(t,e){this.mode=t,this.settings={...e},t===i.MODES.FIXED?this.initializeFixedMode():t===i.MODES.ADAPTIVE&&this.initializeAdaptiveMode()}constructor(){this.lights={},this.mode=i.MODES.FIXED,this.settings={...i.DEFAULT_SETTINGS},this.fixedState={currentPhase:0,phaseTimer:0,isActive:!1},this.adaptiveState={currentPair:null,currentPhase:"red",phaseTimer:0,isActive:!1,greenPairScores:{north:0,south:0,east:0,west:0},redPairScores:{north:0,south:0,east:0,west:0},redPairWaitTimes:{north:0,south:0,east:0,west:0},greenPairApproaching:{north:0,south:0,east:0,west:0},redPairApproaching:{north:0,south:0,east:0,west:0},priorityScores:{WE:0,NS:0},switchThreshold:1.5,maxGreenDuration:1e5,lastSwitchTime:0,firstCarTriggered:!1,nextPair:null,greenLockTime:0,greenLockDuration:5e3,currentGreenCarsPassed:0},this.initializeLights()}initializeLights(){Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t]={state:i.LIGHT_STATES.RED,timer:0}})}initializeFixedMode(){console.log("Initializing Fixed Mode"),this.fixedState={currentPhase:0,phaseTimer:0,isActive:!0},this.setFixedLightState()}initializeAdaptiveMode(){this.adaptiveState.currentPair=null,this.adaptiveState.currentPhase="red",this.adaptiveState.phaseTimer=0,this.adaptiveState.isActive=!0,this.adaptiveState.greenPairScores={north:0,south:0,east:0,west:0},this.adaptiveState.redPairScores={north:0,south:0,east:0,west:0},this.adaptiveState.redPairWaitTimes={north:0,south:0,east:0,west:0},this.adaptiveState.greenPairApproaching={north:0,south:0,east:0,west:0},this.adaptiveState.redPairApproaching={north:0,south:0,east:0,west:0},this.adaptiveState.switchThreshold=1.5,this.adaptiveState.maxGreenDuration=1e5,this.adaptiveState.lastSwitchTime=0,this.adaptiveState.firstCarTriggered=!1,this.setAllLightsRed(),console.log("Adaptive mode initialized - all lights red, waiting for cars")}update(t,e,s){this.mode=e,this.settings={...s},e===i.MODES.FIXED?(this.fixedState.isActive||this.initializeFixedMode(),this.updateFixedMode(t)):e===i.MODES.ADAPTIVE&&(this.adaptiveState.isActive||this.initializeAdaptiveMode(),this.updateAdaptiveMode(t))}updateFixedMode(t){switch(this.fixedState.phaseTimer+=t,this.fixedState.currentPhase){case 0:this.fixedState.phaseTimer>=this.settings.GREEN_DURATION&&this.advanceFixedPhase();break;case 1:this.fixedState.phaseTimer>=this.settings.YELLOW_DURATION&&this.advanceFixedPhase();break;case 2:this.fixedState.phaseTimer>=3e3&&this.advanceFixedPhase();break;case 3:this.fixedState.phaseTimer>=this.settings.GREEN_DURATION&&this.advanceFixedPhase();break;case 4:this.fixedState.phaseTimer>=this.settings.YELLOW_DURATION&&this.advanceFixedPhase();break;case 5:this.fixedState.phaseTimer>=3e3&&this.advanceFixedPhase();break}}advanceFixedPhase(){this.fixedState.currentPhase=(this.fixedState.currentPhase+1)%6,this.fixedState.phaseTimer=0,this.setFixedLightState(),console.log(`Fixed Mode: Advanced to phase ${this.fixedState.currentPhase}`)}setFixedLightState(){switch(this.setAllLightsRed(),this.fixedState.currentPhase){case 0:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.GREEN;break;case 1:this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.YELLOW;break;case 2:break;case 3:this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.GREEN,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.GREEN;break;case 4:this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.YELLOW,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.YELLOW;break}}updateAdaptiveMode(t){if(this.adaptiveState.isActive){if(this.adaptiveState.phaseTimer+=t,this.adaptiveState.currentPair===null){const e=this.getFirstDetectedPair();e&&(console.log(`🚦 FIRST CAR DETECTED! Starting ${e} green phase`),this.switchToAdaptivePair(e),this.startAdaptiveGreen(),this.adaptiveState.firstCarTriggered=!0)}else if(this.adaptiveState.currentPhase==="green"){if(this.adaptiveState.greenLockTime>0)if(this.adaptiveState.greenLockTime=Math.max(0,this.adaptiveState.greenLockTime-t),this.adaptiveState.greenLockTime>0){console.log(`🔒 GREEN LOCK ACTIVE: ${(this.adaptiveState.greenLockTime/1e3).toFixed(1)}s remaining`),this.setAdaptiveLightState();return}else console.log("🔓 GREEN LOCK EXPIRED - Starting score evaluation");const e=this.calculateCurrentGreenPairScore(),s=this.calculateWaitingRedPairScore(),a=this.adaptiveState.phaseTimer>=3e4,r=this.adaptiveState.phaseTimer>=this.adaptiveState.maxGreenDuration,n=e===0,c=s>0,h=n&&c&&this.adaptiveState.phaseTimer>5e3,l=s>e*this.adaptiveState.switchThreshold,T=a||r||h||l;this._scoreLogCounter||(this._scoreLogCounter=0),this._scoreLogCounter++,(this._scoreLogCounter%60===0||T)&&(console.log(`📊 SCORE CHECK: Green=${e.toFixed(1)}, Red=${s.toFixed(1)}, PhaseTime=${(this.adaptiveState.phaseTimer/1e3).toFixed(1)}s, Pair=${this.adaptiveState.currentPair}`),console.log(`   MinGreen=${a}, MaxGreen=${r}, FastTrack=${h}, Threshold=${l}, SWITCH=${T}`)),T?(console.log(`🔄 SWITCHING! Reason: ${r?"MAX GREEN (100s)":a?"MIN GREEN (30s)":h?"FAST-TRACK (Green Idle + Red Demand)":"THRESHOLD EXCEEDED"}`),this.startAdaptiveYellow()):this.adaptiveState.greenLockTime=this.adaptiveState.greenLockDuration}else if(this.adaptiveState.currentPhase==="yellow")this.adaptiveState.phaseTimer>=this.settings.YELLOW_DURATION&&(console.log(`🔴 YELLOW→RED: ${this.adaptiveState.currentPair} going to red`),this.startAdaptiveRed());else if(this.adaptiveState.currentPhase==="red"&&this.adaptiveState.phaseTimer>=2e3){const e=this.adaptiveState.nextPair||this.getOtherPair();console.log(`🟢 RED→GREEN: Switching to GREEN for ${e}`),this.switchToAdaptivePair(e),this.startAdaptiveGreen(),this.adaptiveState.nextPair=null}this.setAdaptiveLightState()}}switchToAdaptivePair(t){this.adaptiveState.currentPair=t,this.adaptiveState.lastSwitchTime=Date.now()}startAdaptiveGreen(){this.adaptiveState.currentPhase="green",this.adaptiveState.phaseTimer=0,this.adaptiveState.greenLockTime=this.adaptiveState.greenLockDuration,this.adaptiveState.currentGreenCarsPassed=0,this.adaptiveState.currentPair==="NS"?(this.adaptiveState.greenPairScores.north=0,this.adaptiveState.greenPairScores.south=0,console.log("✅ GREEN STARTED for NS - Reset carsPassed counters")):this.adaptiveState.currentPair==="WE"&&(this.adaptiveState.greenPairScores.west=0,this.adaptiveState.greenPairScores.east=0,console.log("✅ GREEN STARTED for WE - Reset carsPassed counters"))}startAdaptiveYellow(){this.adaptiveState.currentPhase="yellow",this.adaptiveState.phaseTimer=0}startAdaptiveRed(){this.adaptiveState.currentPhase="red",this.adaptiveState.phaseTimer=0}setAdaptiveLightState(){const t=this.adaptiveState.currentPhase==="green"?i.LIGHT_STATES.GREEN:this.adaptiveState.currentPhase==="yellow"?i.LIGHT_STATES.YELLOW:i.LIGHT_STATES.RED;this.adaptiveState.currentPair==="WE"?(this.lights[i.DIRECTIONS.WEST].state=t,this.lights[i.DIRECTIONS.EAST].state=t,this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.RED,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.RED):this.adaptiveState.currentPair==="NS"?(this.lights[i.DIRECTIONS.NORTH].state=t,this.lights[i.DIRECTIONS.SOUTH].state=t,this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.RED,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.RED):(this.lights[i.DIRECTIONS.NORTH].state=i.LIGHT_STATES.RED,this.lights[i.DIRECTIONS.SOUTH].state=i.LIGHT_STATES.RED,this.lights[i.DIRECTIONS.WEST].state=i.LIGHT_STATES.RED,this.lights[i.DIRECTIONS.EAST].state=i.LIGHT_STATES.RED)}getOtherPair(){return this.adaptiveState.currentPair?this.adaptiveState.currentPair==="WE"?"NS":"WE":null}getFirstDetectedPair(){if(!this.adaptiveState.currentSensorData)return null;const t=this.adaptiveState.currentSensorData,e=this.calculateInitialPairScore("NS",t),s=this.calculateInitialPairScore("WE",t);return console.log(`🔍 FIRST CAR DETECTION - Combined Scores: NS=${e.toFixed(1)}, WE=${s.toFixed(1)}`),e>0&&e>=s?"NS":s>0?"WE":null}calculateInitialPairScore(t,e){if(t==="NS"){const s=e[i.DIRECTIONS.NORTH]||{carsWaiting:0,waitTime:0,carsApproaching:0},a=e[i.DIRECTIONS.SOUTH]||{carsWaiting:0,waitTime:0,carsApproaching:0},r=s.carsWaiting*(s.waitTime/1e3)+(s.carsApproaching||0),n=a.carsWaiting*(a.waitTime/1e3)+(a.carsApproaching||0);return r+n}else{const s=e[i.DIRECTIONS.WEST]||{carsWaiting:0,waitTime:0,carsApproaching:0},a=e[i.DIRECTIONS.EAST]||{carsWaiting:0,waitTime:0,carsApproaching:0},r=s.carsWaiting*(s.waitTime/1e3)+(s.carsApproaching||0),n=a.carsWaiting*(a.waitTime/1e3)+(a.carsApproaching||0);return r+n}}calculateCurrentGreenPairScore(){var e,s,a,r;const t=this.adaptiveState.currentPair;if(!t)return 0;if(t==="NS"){const n=this.adaptiveState.greenPairScores.north||0,c=this.adaptiveState.greenPairScores.south||0,h=((e=this.adaptiveState.greenPairApproaching)==null?void 0:e.north)||0,l=((s=this.adaptiveState.greenPairApproaching)==null?void 0:s.south)||0,T=n+c+h+l;return console.log(`🟢 GREEN SCORE (NS): Passed=${n+c}, Approaching=${h+l}, Total=${T.toFixed(1)}`),T}else{const n=this.adaptiveState.greenPairScores.west||0,c=this.adaptiveState.greenPairScores.east||0,h=((a=this.adaptiveState.greenPairApproaching)==null?void 0:a.west)||0,l=((r=this.adaptiveState.greenPairApproaching)==null?void 0:r.east)||0,T=n+c+h+l;return console.log(`🟢 GREEN SCORE (WE): Passed=${n+c}, Approaching=${h+l}, Total=${T.toFixed(1)}`),T}}getCurrentGreenCarsPassed(){const t=this.adaptiveState.currentPair;return t?t==="NS"?(this.adaptiveState.greenPairScores.north||0)+(this.adaptiveState.greenPairScores.south||0):(this.adaptiveState.greenPairScores.west||0)+(this.adaptiveState.greenPairScores.east||0):0}calculateWaitingRedPairScore(){var e,s,a,r;const t=this.getOtherPair();if(!t)return 0;if(t==="NS"){const n=this.adaptiveState.redPairScores.north||0,c=this.adaptiveState.redPairScores.south||0,h=(this.adaptiveState.redPairWaitTimes.north||0)/1e3,l=(this.adaptiveState.redPairWaitTimes.south||0)/1e3,T=((e=this.adaptiveState.redPairApproaching)==null?void 0:e.north)||0,o=((s=this.adaptiveState.redPairApproaching)==null?void 0:s.south)||0,S=n*h+T,g=c*l+o,E=S+g;return E>0&&console.log(`🔴 RED SCORE (NS): Waiting=${n}/${c}, WaitTime=${h.toFixed(1)}s/${l.toFixed(1)}s, Approaching=${T}/${o}, Total=${E.toFixed(1)}`),E}else{const n=this.adaptiveState.redPairScores.west||0,c=this.adaptiveState.redPairScores.east||0,h=(this.adaptiveState.redPairWaitTimes.west||0)/1e3,l=(this.adaptiveState.redPairWaitTimes.east||0)/1e3,T=((a=this.adaptiveState.redPairApproaching)==null?void 0:a.west)||0,o=((r=this.adaptiveState.redPairApproaching)==null?void 0:r.east)||0,S=n*h+T,g=c*l+o,E=S+g;return console.log(`🔴 RED SCORE (WE): Waiting=${n+c}, WaitTime=${h.toFixed(1)}s/${l.toFixed(1)}s, Approaching=${T+o}, Total=${E.toFixed(1)}`),E}}updateAdaptiveLogic(t,e){if(this.mode!==i.MODES.ADAPTIVE||!this.adaptiveState.isActive)return;t||(t={north:{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0},south:{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0},east:{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0},west:{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0}}),this.adaptiveState.currentSensorData=t,this.adaptiveState.greenPairApproaching||(this.adaptiveState.greenPairApproaching={north:0,south:0,east:0,west:0}),this.adaptiveState.redPairApproaching||(this.adaptiveState.redPairApproaching={north:0,south:0,east:0,west:0});const s=t[i.DIRECTIONS.NORTH]||{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0},a=t[i.DIRECTIONS.SOUTH]||{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0},r=t[i.DIRECTIONS.EAST]||{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0},n=t[i.DIRECTIONS.WEST]||{carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,totalCarsDetected:0};this.adaptiveState.currentPair==="NS"?(this.adaptiveState.greenPairScores.north=s.carsPassed||0,this.adaptiveState.greenPairScores.south=a.carsPassed||0,this.adaptiveState.greenPairApproaching.north=s.carsApproaching||0,this.adaptiveState.greenPairApproaching.south=a.carsApproaching||0,this.adaptiveState.redPairScores.east=r.carsWaiting||0,this.adaptiveState.redPairScores.west=n.carsWaiting||0,this.adaptiveState.redPairWaitTimes.east=r.waitTime||0,this.adaptiveState.redPairWaitTimes.west=n.waitTime||0,this.adaptiveState.redPairApproaching.east=r.carsApproaching||0,this.adaptiveState.redPairApproaching.west=n.carsApproaching||0,(r.carsWaiting>0||n.carsWaiting>0)&&console.log(`🔍 DATA UPDATE (NS=GREEN, WE=RED): East waiting=${r.carsWaiting}, waitTime=${(r.waitTime/1e3).toFixed(1)}s | West waiting=${n.carsWaiting}, waitTime=${(n.waitTime/1e3).toFixed(1)}s`)):this.adaptiveState.currentPair==="WE"?(this.adaptiveState.greenPairScores.east=r.carsPassed||0,this.adaptiveState.greenPairScores.west=n.carsPassed||0,this.adaptiveState.greenPairApproaching.east=r.carsApproaching||0,this.adaptiveState.greenPairApproaching.west=n.carsApproaching||0,this.adaptiveState.redPairScores.north=s.carsWaiting||0,this.adaptiveState.redPairScores.south=a.carsWaiting||0,this.adaptiveState.redPairWaitTimes.north=s.waitTime||0,this.adaptiveState.redPairWaitTimes.south=a.waitTime||0,this.adaptiveState.redPairApproaching.north=s.carsApproaching||0,this.adaptiveState.redPairApproaching.south=a.carsApproaching||0):(this.adaptiveState.greenPairScores.north=s.totalCarsDetected||0,this.adaptiveState.greenPairScores.south=a.totalCarsDetected||0,this.adaptiveState.greenPairScores.east=r.totalCarsDetected||0,this.adaptiveState.greenPairScores.west=n.totalCarsDetected||0)}setAllLightsRed(){Object.values(i.DIRECTIONS).forEach(t=>{this.lights[t].state=i.LIGHT_STATES.RED})}render(t,e){["north","south","east","west"].forEach(a=>{const r=this.lights[i.DIRECTIONS[a.toUpperCase()]].state;this.renderTrafficLight(t,a,r,e)})}renderTrafficLight(t,e,s,a){const r=a.getLightPosition(e);if(!r)return;const n=i.LIGHT_SIZE,c=n+2;t.fillStyle="#333",t.fillRect(r.x-n-1,r.y-c*1.5-1,(n+1)*2,c*3+2),["red","yellow","green"].forEach((l,T)=>{const o=r.y-c+T*c;t.fillStyle="#222",t.beginPath(),t.arc(r.x,o,n,0,Math.PI*2),t.fill(),s===l&&(t.fillStyle=l,t.beginPath(),t.arc(r.x,o,n-2,0,Math.PI*2),t.fill())})}getLightStates(){const t={};return Object.entries(this.lights).forEach(([e,s])=>{t[e]=s.state}),t}setMode(t){this.mode=t,t===i.MODES.FIXED&&!this.fixedState.isActive?this.initializeFixedMode():t===i.MODES.ADAPTIVE&&!this.adaptiveState.isActive&&this.initializeAdaptiveMode()}updateSettings(t){this.settings={...t}}reset(){this.mode===i.MODES.FIXED?(this.fixedState.isActive=!1,this.initializeFixedMode()):this.mode===i.MODES.ADAPTIVE&&(this.adaptiveState.isActive=!1,this.initializeAdaptiveMode()),console.log(`${this.mode} mode reset`)}getDebugInfo(){return this.mode===i.MODES.FIXED?{mode:"Fixed",phase:this.fixedState.currentPhase,timer:(this.fixedState.phaseTimer/1e3).toFixed(1)+"s",active:this.fixedState.isActive}:{mode:"Adaptive",pair:this.adaptiveState.currentPair,phase:this.adaptiveState.currentPhase,timer:(this.adaptiveState.phaseTimer/1e3).toFixed(1)+"s",scores:this.adaptiveState.priorityScores,greenLock:(this.adaptiveState.greenLockTime/1e3).toFixed(1)+"s",greenScores:this.adaptiveState.greenPairScores,redScores:this.adaptiveState.redPairScores,waitTimes:this.adaptiveState.redPairWaitTimes,active:this.adaptiveState.isActive}}}const y={getDistance(d,t,e,s){const a=e-d,r=s-t;return Math.sqrt(a*a+r*r)},getAngle(d,t,e,s){return Math.atan2(s-t,e-d)},getAngleDifference(d,t){let e=t-d;for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e},normalizeAngle(d){for(;d>Math.PI;)d-=2*Math.PI;for(;d<-Math.PI;)d+=2*Math.PI;return d},lerp(d,t,e){return d+(t-d)*e},clamp(d,t,e){return Math.min(Math.max(d,t),e)},randomBetween(d,t){return Math.random()*(t-d)+d},randomInt(d,t){return Math.floor(Math.random()*(t-d+1))+d},randomFromArray(d){return d[Math.floor(Math.random()*d.length)]},formatTime(d){return(d/1e3).toFixed(1)},hexToRgba(d,t=1){const e=parseInt(d.slice(1,3),16),s=parseInt(d.slice(3,5),16),a=parseInt(d.slice(5,7),16);return`rgba(${e}, ${s}, ${a}, ${t})`},isPointInRect(d,t,e,s,a,r){return d>=e&&d<=e+a&&t>=s&&t<=s+r},smoothStep(d,t,e){const s=this.clamp((e-d)/(t-d),0,1);return s*s*(3-2*s)},getBezierPoint(d,t,e,s,a){const r=3*(e.x-t.x),n=3*(s.x-e.x)-r,c=a.x-t.x-r-n,h=3*(e.y-t.y),l=3*(s.y-e.y)-h,T=a.y-t.y-h-l,o=d*d,S=o*d;return{x:c*S+n*o+r*d+t.x,y:T*S+l*o+h*d+t.y}}};class O{constructor({id:t,direction:e,intersection:s,route:a=null,lane:r=0}){this.id=t,this.fromDirection=e,this.intersection=s,this.route=a||[e,"intersection",this.calculateToDirection()],this.lane=r,this.lateralPosition=0,this.turnType=this.calculateTurnType(),this.toDirection=this.route[2];const n=s.getSpawnPointForLane(e,r);this.x=n.x,this.y=n.y,this.angle=this.getInitialAngle(),this.speed=0,this.maxSpeed=i.DEFAULT_SETTINGS.CAR_SPEED,this.width=i.CAR_WIDTH,this.height=i.CAR_HEIGHT,this.color=i.CAR_COLORS[Math.floor(Math.random()*i.CAR_COLORS.length)],this.state="approaching",this.waitStartTime=null,this.totalWaitTime=0,this.isInIntersection=!1,this.pathProgress=0,this.turnStartTime=null,this.trajectorySpec=null,this.trajectoryDistance=0,this.isRegularVeh=!0,this.hasInitializedTrajectory=!1,this.laneOld=r,this.fracLaneOptical=0,this.v=0,this.dvdt=0,this.dt_LC=4,this.dt_afterLC=0,this.calculateTargetPosition()}calculateTurnType(){return this.lane===0?Math.random()<.5?i.TURN_TYPES.LEFT:i.TURN_TYPES.RIGHT:this.lane===1?Math.random()<.889?i.TURN_TYPES.STRAIGHT:i.TURN_TYPES.LEFT:i.TURN_TYPES.STRAIGHT}prepareForTurn(){}updateApproaching(t,e){const s=this.intersection.getStopLinePosition(this.fromDirection),a=this.getDistanceToStopLine(s),r=this.checkForCarAhead(),n=r&&this.getDistanceToCarAhead(r)<25,c=e[this.fromDirection]===i.LIGHT_STATES.RED,h=e[this.fromDirection]===i.LIGHT_STATES.YELLOW,l=e[this.fromDirection]===i.LIGHT_STATES.GREEN,T=(c||h)&&a>0,o=a<=1;if(T&&a<=5||n||o&&!l){this.state="waiting",this.speed=0,(c||h)&&!this.waitStartTime&&(this.waitStartTime=Date.now(),this.totalWaitTime=0,console.log(`⏰ TIMER STARTED IMMEDIATELY: Car ${this.id} waiting at ${this.fromDirection} - Light: ${e[this.fromDirection]}, Distance: ${a.toFixed(1)}`)),console.log(`🛑 Car ${this.id} STOPPED at ${this.fromDirection} - Light: ${e[this.fromDirection]}, Distance: ${a.toFixed(1)}, Reason: ${T?"RED/YELLOW LIGHT":"CAR AHEAD"}, Timer: ${this.waitStartTime?"ACTIVE":"NONE"}`);return}if(c&&a<20&&a>2){const S=Math.max(80,200-a*2);this.speed=Math.max(0,this.speed-S*t),console.log(`🚨 Car ${this.id} braking for RED light - Distance: ${a.toFixed(1)}, Speed: ${this.speed.toFixed(1)}, Braking: ${S.toFixed(1)}`)}else h&&a<15&&a>3?this.speed=Math.max(0,this.speed-50*t):(l||a>15)&&(this.speed=Math.min(this.maxSpeed,this.speed+30*t));this.isInIntersection&&(l?(this.state="crossing",console.log(`🚗 Car ${this.id} entering intersection from ${this.fromDirection} - Light: ${e[this.fromDirection]}`)):(this.speed=0,this.state="waiting",this.waitStartTime||(this.waitStartTime=Date.now()),console.log(`🚨 EMERGENCY STOP! Car ${this.id} stopped at intersection entrance - Light: ${e[this.fromDirection]}`)))}updateCrossing(t){if(typeof this.intersection.getLightStates=="function"){const r=this.intersection.getLightStates();if((r?r[this.fromDirection]:null)===i.LIGHT_STATES.RED&&!this.isInIntersection){this.state="waiting",this.speed=0,console.log(`🚨 Car ${this.id} emergency stop - red light while approaching intersection (crossing state)`);return}}this.speed=Math.min(this.maxSpeed*1.2,this.speed+40*t);const e=this.intersection.centerX,s=this.intersection.centerY,a=Math.sqrt((this.x-e)**2+(this.y-s)**2);if(this.turnType===i.TURN_TYPES.LEFT||this.turnType===i.TURN_TYPES.RIGHT){const r=this.intersection.getPathEntryPoint?this.intersection.getPathEntryPoint(this.fromDirection):null,n=r?Math.sqrt((this.x-r.x)**2+(this.y-r.y)**2):0,c=!r||n<25;a<30&&c&&!this.hasInitializedTrajectory&&(console.log("Car",this.id,"NOW ready to turn - initializing trajectory:",this.turnType),this.initializeTrajectory(),this.hasInitializedTrajectory=!0),this.hasInitializedTrajectory&&this.trajectorySpec?this.followTurnTrajectory(t):(this.x+=Math.cos(this.angle)*this.speed*t,this.y+=Math.sin(this.angle)*this.speed*t,console.log("Car",this.id,"moving straight until ready to turn"))}else this.x+=Math.cos(this.angle)*this.speed*t,this.y+=Math.sin(this.angle)*this.speed*t;!this.isInIntersection&&this.pathProgress>0&&(this.state="exiting"),this.pathProgress+=t}followTurnTrajectory(t){if(!this.trajectorySpec){console.warn("No trajectory spec for car",this.id,"- initializing"),this.initializeTrajectory();return}try{this.trajectoryDistance+=this.speed*t;const e=I(this.trajectoryDistance,this.trajectorySpec);if(!e||e.length<2){console.warn("Invalid position from trajectory for car",this.id,"- using emergency fallback"),this.x+=Math.cos(this.angle)*this.speed*t,this.y+=Math.sin(this.angle)*this.speed*t;return}this.x=e[0],this.y=e[1],(isNaN(this.x)||isNaN(this.y))&&(console.error("Invalid position for car",this.id,"- using fallback position"),this.x=this.intersection.centerX,this.y=this.intersection.centerY);const s=Math.max(2,this.speed*.1),a=I(this.trajectoryDistance+s,this.trajectorySpec);if(a&&a.length>=2){const r=a[0]-this.x,n=a[1]-this.y;(Math.abs(r)>.01||Math.abs(n)>.01)&&(this.angle=Math.atan2(n,r))}console.log("Car",this.id,"trajectory position:",this.x.toFixed(1),this.y.toFixed(1),"angle:",(this.angle*180/Math.PI).toFixed(1))}catch(e){throw console.error("Error in followTurnTrajectory for car",this.id,e),e}}initializeTrajectory(){try{this.trajectorySpec=this.intersection.calculateTrajectory(this.fromDirection,this.toDirection,this.turnType,this.lane),this.trajectorySpec?console.log("Initialized trajectory for car",this.id,"turn type:",this.turnType,"lane:",this.lane):(console.error("Failed to create trajectory for car",this.id,{from:this.fromDirection,to:this.toDirection,turnType:this.turnType,lane:this.lane}),this.createFallbackTrajectory())}catch(t){console.error("Error creating trajectory for car",this.id,t),this.createFallbackTrajectory()}}doSimpleTurn(t){this.intersection.centerX,this.intersection.centerY;const s=this.speed/20;this.turnType===i.TURN_TYPES.LEFT?this.angle+=s*t:this.turnType===i.TURN_TYPES.RIGHT&&(this.angle-=s*t),this.x+=Math.cos(this.angle)*this.speed*t,this.y+=Math.sin(this.angle)*this.speed*t,console.log("Car",this.id,"simple turn - angle:",(this.angle*180/Math.PI).toFixed(1),"position:",this.x.toFixed(1),this.y.toFixed(1))}createFallbackTrajectory(){const t=this.intersection.getPathEntryPoint(this.fromDirection,this.lane),e=this.intersection.getExitPointForTurn(this.fromDirection,this.turnType,this.lane),s=Math.sqrt((e.x-t.x)**2+(e.y-t.y)**2),a=Math.atan2(e.y-t.y,e.x-t.x);this.trajectorySpec=p(t.x,t.y,a,[s],[0]),console.warn("Using fallback trajectory for car",this.id,"lane:",this.lane)}calculateToDirection(){const t=[i.DIRECTIONS.NORTH,i.DIRECTIONS.EAST,i.DIRECTIONS.SOUTH,i.DIRECTIONS.WEST],e=t.indexOf(this.fromDirection);switch(this.turnType){case i.TURN_TYPES.STRAIGHT:return t[(e+2)%4];case i.TURN_TYPES.RIGHT:return t[(e+3)%4];case i.TURN_TYPES.LEFT:return t[(e+1)%4];default:return t[(e+2)%4]}}getInitialAngle(){switch(this.fromDirection){case i.DIRECTIONS.NORTH:return Math.PI/2;case i.DIRECTIONS.EAST:return Math.PI;case i.DIRECTIONS.SOUTH:return-Math.PI/2;case i.DIRECTIONS.WEST:return 0;default:return 0}}calculateTargetPosition(){if(this.intersection&&typeof this.intersection.getExitPoint=="function"&&this.fromDirection){const t=this.intersection.getExitPoint(this.fromDirection);if(!t||typeof t.x!="number"||typeof t.y!="number"){console.warn("Target position is undefined or invalid for car",this.id);return}this.targetX=t.x,this.targetY=t.y}else console.warn("intersection.getExitPoint is not a function or direction is missing")}update(t,e){const s=t/1e3;if(isNaN(this.x)||isNaN(this.y)){console.error("Car",this.id,"has invalid position, resetting to spawn point");const a=this.intersection.getSpawnPointForLane(this.fromDirection,this.lane);this.x=a.x,this.y=a.y,this.state="approaching",this.speed=0}switch(this.state){case"approaching":this.updateApproaching(s,e);break;case"waiting":this.updateWaiting(s,e);break;case"crossing":this.updateCrossing(s);break;case"turning":console.log("Car",this.id,"in turning state - redirecting to crossing"),this.updateTurning(s);break;case"exiting":this.updateExiting(s);break;default:console.warn("Car",this.id,"in unknown state:",this.state,"- setting to exiting"),this.state="exiting"}this.speed>0&&this.state!=="crossing"&&(this.x+=Math.cos(this.angle)*this.speed*s,this.y+=Math.sin(this.angle)*this.speed*s),this.isInIntersection=this.intersection.isInIntersection(this.x,this.y)}updateLaneChangePhysics(t){}startLaneChange(t){console.log("Lane change attempted but disabled for car",this.id)}updateWaiting(t,e){this.speed=0,this.waitStartTime&&(this.totalWaitTime=Date.now()-this.waitStartTime);const s=this.checkForCarAhead(),a=s&&this.getDistanceToCarAhead(s)<20,r=e[this.fromDirection],n=r===i.LIGHT_STATES.GREEN;if(n&&!a)console.log(`🟢 Car ${this.id} proceeding from waiting - Light: ${r}, Wait time: ${(this.totalWaitTime/1e3).toFixed(1)}s`),this.state="crossing",this.waitStartTime=null,this.totalWaitTime=0,this.speed=10,this.trajectorySpec=null,this.trajectoryDistance=0,this.hasInitializedTrajectory=!1;else{this.state="waiting",this.speed=0;const c=n?"Car ahead too close":`Light is ${r}`;this.totalWaitTime%2e3<100&&console.log(`⏰ Car ${this.id} still waiting at ${this.fromDirection} - ${c}, Wait time: ${(this.totalWaitTime/1e3).toFixed(1)}s`)}}updateTurning(t){console.log("Car",this.id,"redirected from turning to crossing state"),this.state="crossing",this.speed<=0&&(this.speed=this.maxSpeed*.8),this.updateCrossing(t)}getExitPosition(t,e,s){const a=this.intersection.centerX,r=this.intersection.centerY,n=i.LANE_WIDTH,c=i.INTERSECTION_SIZE,h=(s-.5)*n,l=c/2+10;let T,o,S,g;switch(t){case i.DIRECTIONS.NORTH:switch(e){case i.TURN_TYPES.STRAIGHT:T=i.DIRECTIONS.SOUTH,o=a+h,S=r+l,g=i.HEADINGS.SOUTH;break;case i.TURN_TYPES.LEFT:T=i.DIRECTIONS.EAST,o=a+l,S=r+h,g=i.HEADINGS.EAST;break;case i.TURN_TYPES.RIGHT:T=i.DIRECTIONS.WEST,o=a-l,S=r-h,g=i.HEADINGS.WEST;break}break;case i.DIRECTIONS.SOUTH:switch(e){case i.TURN_TYPES.STRAIGHT:T=i.DIRECTIONS.NORTH,o=a-h,S=r-l,g=i.HEADINGS.NORTH;break;case i.TURN_TYPES.LEFT:T=i.DIRECTIONS.WEST,o=a-l,S=r-h,g=i.HEADINGS.WEST;break;case i.TURN_TYPES.RIGHT:T=i.DIRECTIONS.EAST,o=a+l,S=r+h,g=i.HEADINGS.EAST;break}break;case i.DIRECTIONS.EAST:switch(e){case i.TURN_TYPES.STRAIGHT:T=i.DIRECTIONS.WEST,o=a-l,S=r+h,g=i.HEADINGS.WEST;break;case i.TURN_TYPES.LEFT:T=i.DIRECTIONS.NORTH,o=a-h,S=r-l,g=i.HEADINGS.NORTH;break;case i.TURN_TYPES.RIGHT:T=i.DIRECTIONS.SOUTH,o=a+h,S=r+l,g=i.HEADINGS.SOUTH;break}break;case i.DIRECTIONS.WEST:switch(e){case i.TURN_TYPES.STRAIGHT:T=i.DIRECTIONS.EAST,o=a+l,S=r-h,g=i.HEADINGS.EAST;break;case i.TURN_TYPES.LEFT:T=i.DIRECTIONS.SOUTH,o=a+h,S=r+l,g=i.HEADINGS.SOUTH;break;case i.TURN_TYPES.RIGHT:T=i.DIRECTIONS.NORTH,o=a-h,S=r-l,g=i.HEADINGS.NORTH;break}break}return{direction:T,x:o,y:S,heading:g}}degreesToRadians(t){return t*Math.PI/180}getTargetExitAngle(){switch(this.toDirection){case i.DIRECTIONS.NORTH:return-Math.PI/2;case i.DIRECTIONS.EAST:return 0;case i.DIRECTIONS.SOUTH:return Math.PI/2;case i.DIRECTIONS.WEST:return Math.PI;default:return this.angle}}updateExiting(t){this.lateralPosition=0,this.route&&this.route.length>1&&(this.route=this.route.slice(1)),this.speed=this.maxSpeed;let e=!1;e=this.x<-100||this.x>i.CANVAS_WIDTH+100||this.y<-100||this.y>i.CANVAS_HEIGHT+100,e&&(console.log("Car",this.id,"exiting canvas at position:",this.x.toFixed(1),this.y.toFixed(1)),this.state="completed")}getDistanceToStopLine(t){const e=this.x+this.width/2*Math.cos(this.angle),s=this.y+this.height/2*Math.sin(this.angle);let a=0;switch(this.fromDirection){case i.DIRECTIONS.NORTH:a=Math.max(0,t.y1-s);break;case i.DIRECTIONS.EAST:a=Math.max(0,e-t.x1);break;case i.DIRECTIONS.SOUTH:a=Math.max(0,s-t.y1);break;case i.DIRECTIONS.WEST:a=Math.max(0,t.x1-e);break;default:a=0}return a}render(t){if(isNaN(this.x)||isNaN(this.y)){console.error("Car",this.id,"has invalid position, skipping render");return}t.save(),t.translate(this.x,this.y),t.rotate(this.angle),t.fillStyle=this.color,t.fillRect(-this.width/2,-this.height/2,this.width,this.height),t.fillStyle="#333333",t.fillRect(-this.width/2+2,-this.height/2+2,this.width-4,3),t.fillRect(-this.width/2+2,this.height/2-5,this.width-4,3),t.restore()}isWaiting(){return this.state==="waiting"}isCompleted(){return this.state==="completed"}getWaitTime(){return this.waitStartTime?Date.now()-this.waitStartTime:this.totalWaitTime}getDirection(){return this.fromDirection}checkForCarAhead(){const t=this.intersection.carManager?this.intersection.carManager.getCars():[];let e=null,s=1/0;for(const a of t){if(a.id===this.id||a.fromDirection!==this.fromDirection||a.lane!==this.lane)continue;let r=!1,n=0;switch(this.fromDirection){case i.DIRECTIONS.NORTH:r=a.y>this.y,n=a.y-this.y-this.height;break;case i.DIRECTIONS.EAST:r=a.x<this.x,n=this.x-a.x-this.width;break;case i.DIRECTIONS.SOUTH:r=a.y<this.y,n=this.y-a.y-this.height;break;case i.DIRECTIONS.WEST:r=a.x>this.x,n=a.x-this.x-this.width;break}r&&n>0&&n<s&&(s=n,e=a)}return e}getDistanceToCarAhead(t){if(!t)return 1/0;switch(this.fromDirection){case i.DIRECTIONS.NORTH:return t.y-this.y-this.height;case i.DIRECTIONS.EAST:return this.x-t.x-this.width;case i.DIRECTIONS.SOUTH:return this.y-t.y-this.height;case i.DIRECTIONS.WEST:return t.x-this.x-this.width;default:return 1/0}}}class C{constructor(t){this.intersection=t,this.cars=[],this.nextCarId=1,this.spawnTimer=0,this.settings={...i.DEFAULT_SETTINGS},this.onCarCompleted=null,this.intersection.carManager=this}initialize(t){this.settings={...t},this.cars=[],this.nextCarId=1,this.spawnTimer=0}update(t,e){this.spawnTimer+=t;const s=1e4/this.settings.CAR_SPAWN_RATE;this.spawnTimer>=s&&(this.spawnCar(),this.spawnTimer=0),this.cars.forEach(n=>{if(n.maxSpeed=this.settings.CAR_SPEED,!n||typeof n.update!="function"){console.error("Invalid car object found, skipping update");return}n.update(t,e)});const r=this.cars.filter(n=>n&&n.isCompleted()).filter(n=>n.x<-100||n.x>i.CANVAS_WIDTH+100||n.y<-100||n.y>i.CANVAS_HEIGHT+100?!0:(console.warn("Car",n.id,"marked as completed but hasn't exited canvas - keeping alive"),n.state="exiting",!1));r.forEach(n=>{console.log("Removing completed car",n.id,"details:",{position:[n.x.toFixed(1),n.y.toFixed(1)],state:n.state,turnType:n.turnType,canvasBounds:{width:i.CANVAS_WIDTH,height:i.CANVAS_HEIGHT},exitedNaturally:n.x<-100||n.x>i.CANVAS_WIDTH+100||n.y<-100||n.y>i.CANVAS_HEIGHT+100}),this.onCarCompleted&&this.onCarCompleted(n)}),this.cars=this.cars.filter(n=>n&&!r.includes(n))}spawnCar(){const t=[i.DIRECTIONS.NORTH,i.DIRECTIONS.EAST,i.DIRECTIONS.SOUTH,i.DIRECTIONS.WEST],e=t[Math.floor(Math.random()*t.length)],a=Math.random()<.1?0:1,r=this.intersection.getSpawnPointForLane(e,a),n=60;if(!this.cars.some(h=>h.fromDirection!==e||h.lane!==a?!1:y.getDistance(h.x,h.y,r.x,r.y)<n)){const h=new O({id:this.nextCarId++,direction:e,intersection:this.intersection,lane:a});this.cars.push(h),console.log("Spawned car",h.id,"from",e,"in lane",a,"at",r.x,r.y,"- Lane 1 is main road now!")}}render(t){this.cars.forEach(e=>e.render(t))}reset(){this.cars=[],this.nextCarId=1,this.spawnTimer=0}updateSettings(t){this.settings={...t}}getCars(){return[...this.cars]}getWaitingCars(t){return this.cars.filter(e=>e.getDirection()===t&&e.isWaiting())}getCurrentCarCount(){return this.cars.length}}class D{constructor(t){this.intersection=t,this.detectorDistance=i.DEFAULT_SETTINGS.DETECTOR_DISTANCE,this.sensorData={},this.carCounts={},this.waitingCars={},this.totalCarsDetected={},this.initializeSensors()}initializeSensors(){Object.values(i.DIRECTIONS).forEach(t=>{this.sensorData[t]={carsWaiting:0,carsApproaching:0,carsPassed:0,waitTime:0,detectedCars:[],firstCarWaitStart:null,totalCarsDetected:0},this.carCounts[t]=0,this.waitingCars[t]=null,this.totalCarsDetected[t]=0})}initialize(t){this.detectorDistance=t,this.initializeSensors()}update(t,e,s){if(Object.values(i.DIRECTIONS).forEach(a=>{this.sensorData[a].carsWaiting=0,this.sensorData[a].carsApproaching=0,this.sensorData[a].detectedCars=[]}),e&&s&&Object.values(i.DIRECTIONS).forEach(a=>{e[a]!==s[a]&&e[a]===i.LIGHT_STATES.GREEN&&s[a]!==i.LIGHT_STATES.GREEN&&(this.sensorData[a].carsPassed=0,console.log(`🟢 GREEN STARTED: ${a.toUpperCase()} - Reset carsPassed counter`),this.waitingCars[a]=null,this.sensorData[a].firstCarWaitStart=null,this.totalCarsDetected[a]=0,this.sensorData[a].totalCarsDetected=0,console.log(`🔄 RESET: ${a.toUpperCase()} - Total car counter reset to 0`))}),this.shouldResetCounts&&(this.resetAllCarCounts(),this.shouldResetCounts=!1),t.forEach(a=>{const r=a.getDirection(),n=this.getDetectionZone(r),c=this.isCarInDetectionZone(a,n);if(!a._countedInDetector&&c&&(a._countedInDetector=!0,this.totalCarsDetected[r]++,this.sensorData[r].totalCarsDetected=this.totalCarsDetected[r],console.log(`🚗 CAR DETECTED: ${r.toUpperCase()} (Total: ${this.totalCarsDetected[r]}) - Car ${a.id}`)),!c&&a._countedInDetector){a._countedInDetector=!1;const o=this.sensorData[r].detectedCars.indexOf(a);o!==-1&&this.sensorData[r].detectedCars.splice(o,1)}const h=e&&e[r]===i.LIGHT_STATES.RED,l=e&&e[r]===i.LIGHT_STATES.GREEN,T=!e||Object.values(e).every(o=>o===i.LIGHT_STATES.RED);c&&l&&!a._passedDuringGreen&&(a._passedDuringGreen=!0,this.sensorData[r].carsPassed++,console.log(`✅ CAR PASSED GREEN: ${r.toUpperCase()} - Car ${a.id} (Total this green: ${this.sensorData[r].carsPassed})`)),!c&&a._passedDuringGreen&&(a._passedDuringGreen=!1),(h||T)&&c?(this.sensorData[r].detectedCars.push(a),a.isWaiting()?(this.sensorData[r].carsWaiting++,this.waitingCars[r]||(this.waitingCars[r]=a,console.log(`⏰ FRONT CAR WAITING: Car ${a.id} from ${r.toUpperCase()} - Starting timer NOW!`),this.sensorData[r].firstCarWaitStart||(a.waitStartTime?(this.sensorData[r].firstCarWaitStart=a.waitStartTime,console.log(`🚨 TIMER STARTED: ${r.toUpperCase()} - Car ${a.id} has been waiting ${(a.getWaitTime()/1e3).toFixed(1)}s`)):(this.sensorData[r].firstCarWaitStart=Date.now(),console.log(`🚨 TIMER STARTED: ${r.toUpperCase()} - Car ${a.id} just stopped (0.0s)`))))):c&&!a.isWaiting()&&this.sensorData[r].carsApproaching++):l&&c&&!a.isWaiting()&&this.sensorData[r].carsApproaching++}),Object.values(i.DIRECTIONS).forEach(a=>{this.waitingCars[a]&&(this.sensorData[a].waitTime=this.waitingCars[a].getWaitTime(),this.waitingCars[a].isWaiting()||(console.log(`✅ FRONT CAR CLEARED: Car ${this.waitingCars[a].id} from ${a} no longer waiting`),this.waitingCars[a]=null,this.sensorData[a].firstCarWaitStart=null))}),this._logCounter||(this._logCounter=0),this._logCounter++,this._logCounter%60===0){const a=Object.entries(this.sensorData).map(([r,n])=>`${r.toUpperCase()}: W=${n.carsWaiting} A=${n.carsApproaching} P=${n.carsPassed} T=${(n.waitTime/1e3).toFixed(1)}s`).join(" | ");console.log(`📊 SENSOR SUMMARY: ${a}`)}return this.sensorData}getDetectionZone(t){const e=this.intersection.getStopLinePosition(t),s=i.ROAD_WIDTH;switch(t){case i.DIRECTIONS.NORTH:return{x1:this.intersection.centerX-s/2,y1:e.y1-this.detectorDistance,x2:this.intersection.centerX+s/2,y2:e.y1};case i.DIRECTIONS.EAST:return{x1:e.x1,y1:this.intersection.centerY-s/2,x2:e.x1+this.detectorDistance,y2:this.intersection.centerY+s/2};case i.DIRECTIONS.SOUTH:return{x1:this.intersection.centerX-s/2,y1:e.y1,x2:this.intersection.centerX+s/2,y2:e.y1+this.detectorDistance};case i.DIRECTIONS.WEST:return{x1:e.x1-this.detectorDistance,y1:this.intersection.centerY-s/2,x2:e.x1,y2:this.intersection.centerY+s/2};default:return{x1:0,y1:0,x2:0,y2:0}}}isCarInDetectionZone(t,e){return t.x>=e.x1&&t.x<=e.x2&&t.y>=e.y1&&t.y<=e.y2}render(t){this.shouldRenderSensors()&&(t.strokeStyle="rgba(255, 165, 0, 0.8)",t.fillStyle="rgba(255, 165, 0, 0.1)",t.lineWidth=2,t.setLineDash([5,5]),Object.values(i.DIRECTIONS).forEach(e=>{const s=this.getDetectionZone(e);t.fillRect(s.x1,s.y1,s.x2-s.x1,s.y2-s.y1),t.strokeRect(s.x1,s.y1,s.x2-s.x1,s.y2-s.y1),this.renderCarCount(t,e,s),this.renderWaitTime(t,e,s)}),t.setLineDash([]))}shouldRenderSensors(){return!0}renderCarCount(t,e,s){const a=this.totalCarsDetected[e]||0;t.fillStyle="rgba(255, 255, 255, 0.95)",t.strokeStyle="#333",t.lineWidth=2,t.font="bold 14px Arial",t.textAlign="center";let r,n;switch(e){case i.DIRECTIONS.NORTH:r=s.x1-40,n=(s.y1+s.y2)/2;break;case i.DIRECTIONS.SOUTH:r=s.x2+40,n=(s.y1+s.y2)/2;break;case i.DIRECTIONS.EAST:r=(s.x1+s.x2)/2,n=s.y1-20;break;case i.DIRECTIONS.WEST:r=(s.x1+s.x2)/2,n=s.y2+30;break}const c=a.toString(),h=t.measureText(c).width,l=Math.max(h+10,30),T=20;t.fillRect(r-l/2,n-T/2,l,T),t.strokeRect(r-l/2,n-T/2,l,T),t.fillStyle="#333",t.fillText(c,r,n+4),t.font="bold 10px Arial",t.fillText(e.charAt(0).toUpperCase(),r,n-15)}renderWaitTime(t,e,s){const a=this.waitingCars[e];if(!a)return;const r=(a.getWaitTime()/1e3).toFixed(1);t.fillStyle="rgba(255, 255, 255, 0.95)",t.strokeStyle="#ff4444",t.lineWidth=1,t.font="bold 10px Arial",t.textAlign="center";let n,c;switch(e){case i.DIRECTIONS.NORTH:n=s.x2+30,c=(s.y1+s.y2)/2;break;case i.DIRECTIONS.SOUTH:n=s.x1-30,c=(s.y1+s.y2)/2;break;case i.DIRECTIONS.EAST:n=(s.x1+s.x2)/2,c=s.y2+30;break;case i.DIRECTIONS.WEST:n=(s.x1+s.x2)/2,c=s.y1-25;break}const h=`${r}s`,l=t.measureText(h).width,T=Math.max(l+6,20),o=14;t.fillRect(n-T/2,c-o/2,T,o),t.strokeRect(n-T/2,c-o/2,T,o),t.fillStyle="#ff4444",t.fillText(h,n,c+2)}updateDetectorDistance(t){this.detectorDistance=t}getSensorData(){return{...this.sensorData}}getCarCounts(){return{...this.carCounts}}getTotalCarsDetected(){return{...this.totalCarsDetected}}resetCarCount(t){this.totalCarsDetected[t]=0}resetAllCarCounts(){Object.values(i.DIRECTIONS).forEach(t=>{this.totalCarsDetected[t]=0}),console.log("Adaptive Mode: Car counts reset for new cycle")}triggerCountReset(){this.shouldResetCounts=!0}reset(){this.initializeSensors()}}class f{constructor(){this.reset()}initialize(){this.reset()}reset(){this.totalCarsPassed=0,this.totalWaitTime=0,this.currentCars=0,this.waitTimes=[]}update(t,e){this.currentCars=t.length}recordCarCompletion(t){this.totalCarsPassed++;const e=t.getWaitTime();e>0&&(this.totalWaitTime+=e,this.waitTimes.push(e))}getStats(){const t=this.waitTimes.length>0?this.waitTimes.reduce((e,s)=>e+s,0)/this.waitTimes.length:0;return{totalCarsPassed:this.totalCarsPassed,averageWaitTime:t/1e3,currentCars:this.currentCars}}}class P{constructor(t){this.intersection=t,this.waitTimers={},this.initializeTimers()}initializeTimers(){Object.values(i.DIRECTIONS).forEach(t=>{this.waitTimers[t]={startTime:null,isActive:!1}})}startTimer(t){this.waitTimers[t].isActive||(this.waitTimers[t].startTime=Date.now(),this.waitTimers[t].isActive=!0)}stopTimer(t){this.waitTimers[t].startTime=null,this.waitTimers[t].isActive=!1}getWaitTime(t){return!this.waitTimers[t].isActive||!this.waitTimers[t].startTime?0:Date.now()-this.waitTimers[t].startTime}update(t,e){Object.values(i.DIRECTIONS).forEach(s=>{const a=e[s]===i.LIGHT_STATES.RED,r=t[s]&&t[s].carsWaiting>0;a&&r?(this.waitTimers[s].isActive||console.log(`✅ Wait Timer STARTED for ${s} (${t[s].carsWaiting} cars waiting)`),this.startTimer(s)):(this.waitTimers[s].isActive&&console.log(`❌ Wait Timer STOPPED for ${s}`),this.stopTimer(s))})}render(t){Object.values(i.DIRECTIONS).forEach(e=>{this.waitTimers[e].isActive&&this.renderTimer(t,e)})}renderTimer(t,e){const a=(this.getWaitTime(e)/1e3).toFixed(1);let r=this.getTimerPosition(e);t.save(),t.fillStyle="rgba(255, 255, 255, 0.95)",t.strokeStyle="#ff0000",t.lineWidth=3;const n=`${a}s`;t.font="bold 24px Arial",t.textAlign="center",t.textBaseline="middle";const h=t.measureText(n).width+20,l=40;t.fillRect(r.x-h/2,r.y-l/2,h,l),t.strokeRect(r.x-h/2,r.y-l/2,h,l),t.fillStyle="#ff0000",t.fillText(n,r.x,r.y),t.restore()}getTimerPosition(t){const e=this.intersection.centerX,s=this.intersection.centerY,a=150;switch(t){case i.DIRECTIONS.NORTH:return{x:e,y:s-a};case i.DIRECTIONS.SOUTH:return{x:e,y:s+a};case i.DIRECTIONS.EAST:return{x:e+a,y:s};case i.DIRECTIONS.WEST:return{x:e-a,y:s};default:return{x:e,y:s}}}reset(){this.initializeTimers()}}class v{constructor(t,e){this.canvas=t,this.ctx=e,this.intersection=new N(i.CANVAS_WIDTH/2,i.CANVAS_HEIGHT/2),this.mode=i.MODES.FIXED,this.fixedMode={trafficLights:new u,carManager:new C(this.intersection),sensorSystem:new D(this.intersection),statistics:new f,settings:{...i.DEFAULT_SETTINGS}},this.adaptiveMode={trafficLights:new u,carManager:new C(this.intersection),sensorSystem:new D(this.intersection),statistics:new f,waitTimerDisplay:new P(this.intersection),settings:{...i.DEFAULT_SETTINGS,YELLOW_DURATION:3e3}}}initialize(){this.intersection.setCarManager(this.fixedMode.carManager),this.fixedMode.trafficLights.initialize(i.MODES.FIXED,this.fixedMode.settings),this.fixedMode.carManager.initialize(this.fixedMode.settings),this.fixedMode.sensorSystem.initialize(this.fixedMode.settings.DETECTOR_DISTANCE),this.fixedMode.statistics.initialize(),this.fixedMode.carManager.onCarCompleted=t=>{this.fixedMode.statistics.recordCarCompletion(t)},this.adaptiveMode.trafficLights.initialize(i.MODES.ADAPTIVE,this.adaptiveMode.settings),this.adaptiveMode.carManager.initialize(this.adaptiveMode.settings),this.adaptiveMode.sensorSystem.initialize(this.adaptiveMode.settings.DETECTOR_DISTANCE),this.adaptiveMode.statistics.initialize(),this.adaptiveMode.carManager.onCarCompleted=t=>{this.adaptiveMode.statistics.recordCarCompletion(t)},console.log("Game engine initialized")}update(t){const e=this.getCurrentModeComponents();if(this.prevLightStates||(this.prevLightStates=e.trafficLights.getLightStates()),e.trafficLights.update(t,this.mode,e.settings),this.intersection.setCarManager(e.carManager),e.carManager.update(t,e.trafficLights.getLightStates()),this.mode===i.MODES.ADAPTIVE){const s=e.sensorSystem.update(e.carManager.getCars(),e.trafficLights.getLightStates(),this.prevLightStates);e.trafficLights.updateAdaptiveLogic(s,t),e.waitTimerDisplay.update(s,e.trafficLights.getLightStates())}else e.sensorSystem.update(e.carManager.getCars());this.prevLightStates=e.trafficLights.getLightStates(),e.statistics.update(e.carManager.getCars(),t)}render(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);const t=this.getCurrentModeComponents();this.intersection.render(this.ctx),this.mode===i.MODES.ADAPTIVE&&t.sensorSystem.render(this.ctx),t.carManager.render(this.ctx),t.trafficLights.render(this.ctx,this.intersection)}reset(){this.fixedMode.carManager.reset(),this.fixedMode.trafficLights.reset(),this.fixedMode.sensorSystem.reset(),this.fixedMode.statistics.reset(),this.adaptiveMode.carManager.reset(),this.adaptiveMode.trafficLights.reset(),this.adaptiveMode.sensorSystem.reset(),this.adaptiveMode.statistics.reset(),console.log("Game reset")}getCurrentModeComponents(){return this.mode===i.MODES.FIXED?this.fixedMode:this.adaptiveMode}updateMode(t){const e=this.mode;this.mode=t,t===i.MODES.ADAPTIVE&&e!==i.MODES.ADAPTIVE&&this.adaptiveMode.sensorSystem.resetAllCarCounts(),console.log(`Mode changed from ${e} to: ${t}`)}updateSetting(t,e,s=null){const r=(s||this.mode)===i.MODES.FIXED?this.fixedMode:this.adaptiveMode;switch(r.settings[t]=e,t){case"CAR_SPAWN_RATE":case"CAR_SPEED":case"TURN_RATE":r.carManager.updateSettings(r.settings);break;case"DETECTOR_DISTANCE":r.sensorSystem.updateDetectorDistance(e);break;case"NORTH_SOUTH_GREEN_TIME":case"EAST_WEST_GREEN_TIME":case"YELLOW_TIME":case"RED_TIME":case"GREEN_DURATION":case"YELLOW_DURATION":case"RED_DURATION":case"MIN_GREEN_TIME":r.trafficLights.updateSettings(r.settings);break}}updateSettings(t){const e=this.getCurrentModeComponents();e.settings={...e.settings,...t},e.trafficLights.updateSettings(e.settings),e.carManager.updateSettings(e.settings)}getStatistics(){return this.getCurrentModeComponents().statistics.getStats()}getLightStates(){return this.getCurrentModeComponents().trafficLights.getLightStates()}getCurrentMode(){return this.mode}getSettings(){return{...this.getCurrentModeComponents().settings}}getFixedModeSettings(){return{...this.fixedMode.settings}}getAdaptiveModeSettings(){return{...this.adaptiveMode.settings}}getSensorSystem(){return this.getCurrentModeComponents().sensorSystem}setLaneMapping(t,e,s){this.laneMapping=t,this.paths=e,this.getPathIndex=s}assignPathToCar(t){const e=this.getPathIndex(t.dir,t.lane,t.move);e!==null&&this.paths[e]&&(t.path=this.paths[e],t.pathIndex=e,t.pathProgress=0)}updateCarPathFollowing(t,e){if(!t.path||t.pathProgress>=t.path.length)return;const s=t.path[t.pathProgress],a=s.x-t.x,r=s.y-t.y,n=Math.sqrt(a*a+r*r),c=t.speed*e;n<c?(t.x=s.x,t.y=s.y,t.pathProgress++):(t.x+=a/n*c,t.y+=r/n*c)}}class x{constructor(t){this.gameEngine=t,this.elements={},this.isPlaying=!0,this.initializeElements()}initializeElements(){this.elements={modeSelect:document.getElementById("mode-select"),playPauseBtn:document.getElementById("playPauseBtn"),resetBtn:document.getElementById("resetBtn"),fixedControls:document.getElementById("fixed-controls"),greenDuration:document.getElementById("greenDuration"),greenValue:document.getElementById("greenDurationValue"),yellowDuration:document.getElementById("yellowDuration"),yellowValue:document.getElementById("yellowDurationValue"),redDuration:document.getElementById("redDuration"),redValue:document.getElementById("redDurationValue"),adaptiveControls:document.getElementById("adaptive-controls"),detectorDistance:document.getElementById("detectorDistance"),minGreenTime:document.getElementById("minGreenTime"),detectorValue:document.getElementById("detectorValue"),minGreenValue:document.getElementById("minGreenValue"),adaptiveYellowDuration:document.getElementById("adaptiveYellowDuration"),adaptiveYellowValue:document.getElementById("adaptiveYellowValue"),carSpawnRate:document.getElementById("carSpawnRate"),carSpeed:document.getElementById("carSpeed"),spawnValue:document.getElementById("spawnValue"),speedValue:document.getElementById("speedValue"),carsPassedStat:document.getElementById("carsPassedStat"),avgWaitStat:document.getElementById("avgWaitStat"),currentCarsStat:document.getElementById("currentCarsStat"),northCountStat:document.getElementById("northCountStat"),southCountStat:document.getElementById("southCountStat"),eastCountStat:document.getElementById("eastCountStat"),westCountStat:document.getElementById("westCountStat"),northLight:document.getElementById("north-light"),eastLight:document.getElementById("east-light"),southLight:document.getElementById("south-light"),westLight:document.getElementById("west-light")}}initialize(){this.setupEventListeners(),this.updateModeDisplay(),this.startStatsUpdate()}setupEventListeners(){this.elements.modeSelect.addEventListener("change",t=>{this.gameEngine.updateMode(t.target.value),this.updateModeDisplay(),this.updateSliderValues()}),this.elements.playPauseBtn.addEventListener("click",()=>{this.isPlaying=window.trafficSimulator.togglePause(),this.elements.playPauseBtn.textContent=this.isPlaying?"⏸️ Pause":"▶️ Play"}),this.elements.resetBtn.addEventListener("click",()=>{this.gameEngine.reset()}),this.setupSlider("greenDuration","greenValue","NORTH_SOUTH_GREEN_TIME",t=>t*1e3),this.setupSlider("yellowDuration","yellowValue","YELLOW_TIME",t=>t*1e3),this.setupSlider("redDuration","redValue","RED_TIME",t=>t*1e3),this.setupSlider("detectorDistance","detectorValue","DETECTOR_DISTANCE"),this.setupSlider("minGreenTime","minGreenValue","MIN_GREEN_TIME",t=>t*1e3),this.setupSlider("adaptiveYellowDuration","adaptiveYellowValue","YELLOW_TIME",t=>t*1e3),this.setupSlider("carSpawnRate","spawnValue","CAR_SPAWN_RATE"),this.setupSlider("carSpeed","speedValue","CAR_SPEED")}setupSlider(t,e,s,a=null){const r=this.elements[t],n=this.elements[e];!r||!n||(r.addEventListener("input",c=>{const h=parseFloat(c.target.value);n.textContent=h;const l=a?a(h):h;s==="NORTH_SOUTH_GREEN_TIME"?(this.gameEngine.updateSetting("NORTH_SOUTH_GREEN_TIME",l),this.gameEngine.updateSetting("EAST_WEST_GREEN_TIME",l)):s==="YELLOW_TIME"?t==="adaptiveYellowDuration"?this.gameEngine.updateSetting(s,l,i.MODES.ADAPTIVE):this.gameEngine.updateSetting(s,l,i.MODES.FIXED):this.gameEngine.updateSetting(s,l)}),n.textContent=r.value)}updateSliderValues(){const t=this.gameEngine.getCurrentMode(),e=this.gameEngine.getSettings();t===i.MODES.FIXED?(this.elements.greenDuration.value=e.NORTH_SOUTH_GREEN_TIME/1e3,this.elements.greenValue.textContent=e.NORTH_SOUTH_GREEN_TIME/1e3,this.elements.yellowDuration.value=e.YELLOW_TIME/1e3,this.elements.yellowValue.textContent=e.YELLOW_TIME/1e3,this.elements.redDuration.value=e.RED_TIME/1e3,this.elements.redValue.textContent=e.RED_TIME/1e3):(this.elements.detectorDistance.value=e.DETECTOR_DISTANCE,this.elements.detectorValue.textContent=e.DETECTOR_DISTANCE,this.elements.minGreenTime.value=e.MIN_GREEN_TIME/1e3,this.elements.minGreenValue.textContent=e.MIN_GREEN_TIME/1e3,this.elements.adaptiveYellowDuration&&(this.elements.adaptiveYellowDuration.value=e.YELLOW_TIME/1e3,this.elements.adaptiveYellowValue.textContent=e.YELLOW_TIME/1e3)),this.elements.carSpawnRate.value=e.CAR_SPAWN_RATE,this.elements.spawnValue.textContent=e.CAR_SPAWN_RATE,this.elements.carSpeed.value=e.CAR_SPEED,this.elements.speedValue.textContent=e.CAR_SPEED}updateModeDisplay(){this.gameEngine.getCurrentMode()===i.MODES.FIXED?(this.elements.fixedControls.style.display="block",this.elements.adaptiveControls.style.display="none"):(this.elements.fixedControls.style.display="none",this.elements.adaptiveControls.style.display="block")}startStatsUpdate(){setInterval(()=>{this.updateStatistics(),this.updateLightStatus()},100)}updateStatistics(){const t=this.gameEngine.getStatistics(),e=this.gameEngine.getSensorSystem().getTotalCarsDetected();this.elements.carsPassedStat.textContent=t.totalCarsPassed,this.elements.avgWaitStat.textContent=t.averageWaitTime.toFixed(1)+"s",this.elements.currentCarsStat.textContent=t.currentCars,this.gameEngine.getCurrentMode()==="adaptive"?(this.elements.northCountStat.textContent=e.north||0,this.elements.southCountStat.textContent=e.south||0,this.elements.eastCountStat.textContent=e.east||0,this.elements.westCountStat.textContent=e.west||0):(this.elements.northCountStat.textContent="-",this.elements.southCountStat.textContent="-",this.elements.eastCountStat.textContent="-",this.elements.westCountStat.textContent="-")}updateLightStatus(){const t=this.gameEngine.getLightStates(),e={[i.DIRECTIONS.NORTH]:this.elements.northLight,[i.DIRECTIONS.EAST]:this.elements.eastLight,[i.DIRECTIONS.SOUTH]:this.elements.southLight,[i.DIRECTIONS.WEST]:this.elements.westLight};Object.entries(t).forEach(([s,a])=>{const r=e[s];r&&(r.classList.remove("red","yellow","green"),r.classList.add(a))})}setMode(t){this.elements.modeSelect.value=t}updateSliderValue(t,e){const s=this.elements[t];s&&(s.value=e,s.dispatchEvent(new Event("input")))}}document.getElementById("greenDuration").min=15;document.getElementById("greenDuration").max=100;document.getElementById("redDuration").min=15;document.getElementById("redDuration").max=100;const R=document.getElementById("greenDuration"),w=document.getElementById("greenDurationValue");R.addEventListener("input",()=>{w.textContent=R.value});class L{constructor(){this.canvas=document.getElementById("gameCanvas"),this.ctx=this.canvas.getContext("2d"),this.gameEngine=new v(this.canvas,this.ctx),this.uiController=new x(this.gameEngine),this.trafficLightController=new u,this.isRunning=!0,this.lastTime=0,this.initializeGame(),this.startGameLoop()}initializeGame(){this.canvas.width=i.CANVAS_WIDTH,this.canvas.height=i.CANVAS_HEIGHT,this.gameEngine.initialize(),this.uiController.initialize(),console.log("Traffic Simulator initialized")}startGameLoop(){const t=e=>{const s=e-this.lastTime;if(this.lastTime=e,this.isRunning){const a={GREEN_DURATION:Number(document.getElementById("greenDuration").value)*1e3,YELLOW_DURATION:Number(document.getElementById("yellowDuration").value)*1e3,RED_DURATION:Number(document.getElementById("redDuration").value)*1e3,CAR_SPAWN_RATE:Number(document.getElementById("carSpawnRate").value),CAR_SPEED:Number(document.getElementById("carSpeed").value),MIN_GREEN_TIME:5e3,DETECTOR_DISTANCE:200};this.gameEngine.updateSettings(a),this.gameEngine.update(s)}this.gameEngine.render(),requestAnimationFrame(t)};requestAnimationFrame(t)}pause(){this.isRunning=!1}resume(){this.isRunning=!0}reset(){this.gameEngine.reset()}togglePause(){return this.isRunning=!this.isRunning,this.isRunning}}document.addEventListener("DOMContentLoaded",()=>{window.trafficSimulator=new L});
